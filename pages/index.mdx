import { Head } from "../components/Head"
import { App } from "../components/App"

<Head />

# Random Emojis

A live feed of random emojis using Cloudflare, WebSockets and Redux.

<App />

## User Stories

As one of Cadell's friends, I want a live feed of random emojis that I can add to so I can send and receive random emojis for some mild amusement.

As Cadell, I want to build a realtime application using WebSockets and Cloudflare because they're all cool and I haven't used any of them before.

As Cadell, I want to build a stateful application using Cloudflare's Durable Objects so I can decide whether to use it for future applications, like [Very Nested](https://verynested.cadell.dev).

## Background

Cloudflare is pretty hot at the moment. They've announced [R2](https://news.ycombinator.com/item?id=28682237) which is a cheap alternative to AWS S3 with a smooth migration path, making for some serious competition to AWS, [Cloudflare Pages has gone full stack](https://news.ycombinator.com/item?id=29253032) allowing you to deploy fullstack applications with ease and Durable Objects is a new kind of data store that [sounds really interesting](https://blog.cloudflare.com/durable-objects-easy-fast-correct-choose-three/).

I've got a soft spot for stateful applications because they let people interact with each other and that can be fun! I made a chat app 12 years ago in high school using a LAMP stack and free hosting which would later go on to get hacked, leaking my severely reused password to the world. But before that, my friends played with my chat app and we had some laughs.

I recently deployed [PRAwN Stack](https://prawn.cadell.dev) on AWS with a React frontend, NodeJS Lambda backend and a Postgres data store and I'm really happy with the result but deploying it to AWS was a journey to say the least. I think I've been spoilt by [Netlify](https://www.netlify.com/) which makes deployments very easy. I've used it for multiple [frontend applications](https://cadell.dev) and some backend functions for [Very Nested](https://verynested.cadell.dev) but nothing fullstack because they recommend using another provider like AWS for a data store which largely defeats the purpose of using Netlify in my opinion. I can probably reuse PRAwN Stack](https://prawn.cadell.dev) going forward but what other options are there? Firebase springs to mind but it comes with it's own trade-offs. Vercel and Netlify have raised a lot of money recently, maybe they'll move into this space?

[Cloudflare Pages going fullstack](https://news.ycombinator.com/item?id=29253032) means Cloudflare already is which is particularly exciting because they seem to be moving quickly in general with things like R2. Cloudflare already has a powerful CDN for static assets, workers for backend functions and Durable Objects for a datastore, if they can tie all that together with something half as good as Netlify then that's going to be massive. 

And it doesn't stop there because they also [support WebSockets](https://blog.cloudflare.com/introducing-websockets-in-workers/), allowing us to build realtime applications too! The only thing better than a stateful application is a realtime stateful application, just look at Google Docs and Notion. Cloudflare have recently [reduced the costs of using WebSockets](https://blog.cloudflare.com/workers-optimization-reduces-your-bill/) too which is another bonus. Glenn Maddern describes their experience with building a realtime application with Cloudflare really well in this article, [Durable Objects in production](https://news.ycombinator.com/item?id=25084470). It was a massive inspiration for this project.

Diving in deeper, realtime applications are a thing all on their own. There's a range of solutions out there and each has their own trade-offs. CRDTs are pretty hot right now too, like [SyncedStore](https://news.ycombinator.com/item?id=29483913) which builds on [Yjs](https://github.com/yjs/yjs). Another option is [Automerge](https://news.ycombinator.com/item?id=16309533) which looks like it might play nicer with Redux and then there's this fun article on the [performance and optimisations of CRDT solutions](https://news.ycombinator.com/item?id=28017204). It goes deep. [Figma found CRDTs were overkill](https://news.ycombinator.com/item?id=21378858) for their use case because they had a central server to act as a source of truth. CRDTs seem better suited for peer to peer communication but they did use them for inspiration.

I decided to do the same. I was already familiar with Redux and it seems perfect for realtime applications. In Redux, users trigger Actions that are then handled by Reducers to update a central data store. Actions already contain all the information required for the Reducer to update the data store, can't we just send them around to build a realtime application? I found [Logux](https://logux.io/), [@localfirst/state](https://github.com/local-first-web/state) and [some others](https://github.com/markerikson/redux-ecosystem-links/blob/master/store.md#synchronization) seem to have a similar idea but I couldn't see how they would work with Cloudflare so I decided against them in favour of rolling my own.

## Solution

![sequence diagram](/sequence.png)
[Sequence Diagram in MermaidJS](https://mermaid.live/edit/#pako:eNrtlD1PwzAQhv_K4YWlDHTM0AlWQEKIJcslftu6JOfiD6qq4r9zIQkFRFvETKbEeZ873yPLO1N7C1MYinjOkBpXjheB21KIc_KS2wpBP_RZc0iudmuWRA8RgS4PrE9L6f_0qYvZ7NGHJ4SCGqTzSLUXQZ0oRycL2qCKvn5Cij3UZxW6yoGrBnRbrTRdUPQtvIA22ihS8ifqfMV_qpd8AKUlxkLOywF03P8SATpAx6D1Kxe1K9U5BEhqtrTkF3wbolfwQXYz0DzLgI-ibnwCBbdYJvJzGpm7hredTtLqCH1b1lb8xe_03-_0D36nn_xGiI3EA3XCLlurUa97DGP-qNaj1K8lqgrB5ii6l7gdjtCEeE-pvUgVIN1eYA-e0z08OP1U4-ydMhPTIrTsrF4cu26pNDpYi9IU-mox59yk0pTyqtG8tpxwbZ1OYoo5NxET090t91upTZFCxhga7p4h9foGWI6T6Q)

After all that background reading, the solution is quite simple. The frontend is a NextJS app with Redux, the API is a Cloudflare Worker and the data store is a Cloudflare Durable Object. The frontend sets up a WebSocket connection with the Worker which then effectively acts as a proxy for the Durable Object. When the connection is first established the Durable Object will send down the current feed of Emojis and remembers the connection for syncing updates later on.

One interesting thing to note is this connection is stored in the Durable Object's memory, instead of persisted storage. This is because the Durable Object is alive for the entire time the client is connected. That's why [Glenn Maddern thinks about them like Stateful Workers](https://news.ycombinator.com/item?id=25084470), rather than Durable Objects, and I have to agree. More on this later.

 Clicking the Add Emoji button creates a new Redux Action which a Reducer handles to update the local data store which then updates the page to display the new emoji using React. Nothing groundbreaking here but here's the fun part. That Action is also sent through the existing WebSocket connection to the Durable Object. The Durable Object then stores that emoji in the persisted feed and broadcasts that Action to other connected users through their WebSocket connections. That Action is received just like the local Action did, updating the local data store with the same Reducer which updates the page to display the new emoji.

This is deployed with Cloudflare Pages which builds our code and deploys it as part of a pipeline triggered on new commits. This is the same experience Netlify provides and it's really nice but I later learned Durable Objects need to be deployed separately. More on that later.

And that's it! That's how I built a stateful, realtime application which, as discussed earlier, is definitely fun.

## Implementation

This was a fun project overall. There were certainly rough parts but now that it's all working I'm really happy with how it's all turned out. Sharing Redux actions over WebSockets works well and the [Durable Object code](https://github.com/cadbox1/random-emojis/blob/main/durable_objects/src/document.ts) looks great.

Glen Maddern describes Durable Objects as Stateful Workers in [Durable Objects in production](https://news.ycombinator.com/item?id=25084470) and I have to agree now that I've worked with them. Durable Objects work just like workers with some persistence methods added on top. This is particularly evident with WebSockets because the Durable Object is kept alive for the entire duration of the connection so we actually store the connection in memory rather the persisting it. I don't think there's much of a distinction between the two options in the docs, maybe because it's only relevant when using WebSockets.

I've built NextJS apps with MDX and custom components [before](https://github.com/cadbox1/prawn-stack) and decided to split them out into a reusable package for this project. The result is [cadells-vanilla-components](https://github.com/cadbox1/cadells-vanilla-components) and it's used in this [NextJS template](https://github.com/cadbox1/cadells-nextjs-template) I built to go with it. Creating the package was a bit harder than I first thought and it wasn't critical for this project but I'm really happy with the result and creating NextJS apps should be easier going forward. I originally tried using [tsdx](https://github.com/jaredpalmer/tsdx) but the typescript types weren't correct and I couldn't work out why. I started looking for a tool that used [esbuild](https://github.com/evanw/esbuild) instead of [Rollup](https://github.com/rollup/rollup) and found [tsup](https://github.com/egoist/tsup) which pretty much worked out of the box. Happy days! Tsdx did introduce me to [np](https://github.com/sindresorhus/np) for publishing to NPM and it works really well so everything happened for a reason.

[ up to here ]

## Challenges

Cloudflare Pages presented a few challenges:
1. Cloudflare Pages has Functions which are just Cloudflare Workers but there are some slight differences and a lot of the Workers docs take some adjustment.
1. I couldn't find any logs for my Cloudflare Pages Functions, making debugging slow.
1. The relationship between Durable Objects and Pages wasn't clearly documented. I eventually worked out Durable Objects are deployed separately but it took me a while to get there. The steps in the readme are also misleading.
1. My first Cloudflare Pages deploy failed with NextJS, needed to specify a node version with nvmrc.

I haven't deployed a package to NPM before so it took me a bit of time to work that out. I started with [TSDX](https://github.com/jaredpalmer/tsdx) but ran into some typescript issues that I still don't fully understand. Thankfully, I tried [tsup](https://github.com/egoist/tsup) and it worked more or less out of the box. I also used [np](https://github.com/sindresorhus/np) for releasing to NPM which has brought [cadells-vanilla-components](https://github.com/cadbox1/cadells-vanilla-components) into the world. It doesn't have Storybook or anything like that but it's working well enough so far.


## Milestones

- ✅ Setup Cloudflare account.
- ✅ Deploy NextJS website.
- ✅ Setup Redux.
- ✅ Create my first Worker function.
- ✅ Setup a WebSocket connection with a Worker. (2.5h to get to this point)
- ✅ Deploy a Durable Object. (2h)
    - create a durable object
        - resources
            - https://blog.cloudflare.com/building-full-stack-with-pages/
            - https://github.com/cloudflare/images.pages.dev
            - https://developers.cloudflare.com/pages/platform/functions#durable-object-namespace
            - https://developers.cloudflare.com/workers/learning/using-durable-objects#uploading-a-durable-object-worker
        - I thought you could just put a file in the durable_objects folder but that doesn't appear to be the case
            - https://github.com/cloudflare/images.pages.dev/tree/main/durable_objects
            - here's a ts template
                - https://github.com/cloudflare/durable-objects-typescript-rollup-esm
            - doesn't work by itself, you have to publish inside the folder
                - requires npx wrangler login, which isn't mentioned
                - npm run publish then goes on to produce a strange error about agreements which I interpreted as durable objects not being supported in the free tier
                    - Workers > Plan > Paid to set that up
            - npx run publish then goes onto produce the same error but this time it actually shows a prompt where you can agree
                - I think this was meant to come up before, probably a bug
            - finally npx run publish works and now I understand it better - it creates a durable object that you can manually bind in pages to access it. that sure was confusing
- ✅ Access the Durable Object from a Worker. (1.5h)
    - builds failed due to an internal error which was annoying
    - needed to add more error logging because again I can't see builds
- ✅ Setup a Durable Worker for messages. (2h)
    - https://github.com/cloudflare/workers-chat-demo/blob/master/src/chat.mjs
- ✅ Send random emojis instead of a "Tik" message. (1h)
- ✅ Setup Typescript for the Durable Object - 1h
    - https://github.com/cloudflare/durable-objects-typescript-rollup-esm
- ✅ Create a reusable npm package for components and styles. (3h)
    - https://github.com/cadbox1/cadells-vanilla-components
- ✅ Style this and setup MDX. (1.5h)
- Write about the project and my experience.